<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <script>
    const object1 = {
      userid: 123,
      username: 'jaime',
      tel: '18812612345'
    }
    // encodeURI()和encodeURIComponent()都是对URL编码的函数
    // encodeURI()主要用于整个 URI(例如，http://www.wrox.com/illegal value.htm)，
    // encodeURIComponent()主要用于对 URI 中的某一段(例如前面 URI 中的 illegal value.htm)进行编码。 
    // 它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、 问号和井字号;
    // encodeURIComponent()则会对它发现的任何非标准字符进行编码
    // 这也正是可以 对整个 URI 使用 encodeURI()，而只能对附加在现有 URI 后面的字符串使用 encodeURIComponent() 的原因所在
    // 一般来说，我们使用 encodeURIComponent()方法的时候要比使用 encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI 进行编码。

    // 转查询字符串
    const qr = new URLSearchParams(object1).toString()
    const qr1 = Object.entries(object1).map(item => `${item[0]}=${encodeURIComponent(item[1])}`).join('&')
    const qr2 = Object.entries(object1).map(([k, v]) => `${k}=${encodeURIComponent(v)}`).join('&')
    console.log(qr2)

    // 获取url第一个?后的查询内容包括问号
    var queryStr = decodeURIComponent(location.search)
    console.log(queryStr)

    // 上述内容转json
    // arr.map(([k,v]) => ({[k]: v})) 记个笔记
    const arr = queryStr.split("?")[1].split("&").map(item => item.split('='))
    var obj1 = Object.fromEntries(arr)
    const obj2 = arr.reduce((sum, [k,v]) => ({ ...sum, [k]:v }), {})
    // 这里有问题，重复的key会被覆盖
    console.log(arr)

    // 如果键有重复则值以数组呈现
    var res = {}
    arr.forEach(item => {
      if (!res[item[0]]) {
        res[item[0]] = item[1]
      } else {
        res[item[0]] = (res[item[0]]+','+item[1]).split(',')
      }
    })
    console.log(res)
  </script>
</body>
</html>